## 对输入输出流的验证
### 输入流的结束标志
```
while(cin >> num1)
```
对于输入流，当输入流的类型非法（如输入char，被输入的变量为int），或者遇到文件结束符时，`cin >> num1`返回`false`, 每次回车将会把当前行的内容传给流，遇到空格结束，因此若输入 `1 2 3 y` 在回车时，因为有非法字符，将结束循环。而输入 `1 2 3 4` 则不会，输入回车后会开启新的一行，等待输入。文件结束符在Windows下为Ctrl+Z，在Linux下则为Ctrl+D，文件结束符在一行内有别的内容用空格隔开时不会生效，例如: `1 2 3 Ctrl+D` Ctrl+D将无效。但是单独一行输入`Ctrl+D`将直接结束流的输入(不需要回车)

### 输入输出流的级联
```C++
cin >> num1 >> num2
cout << num1 << num2
```
输入输出流级联时，表达式从左向右进行运算，每次将内容写入流（或从流写入变量）时后，其返回流本身，因此上述表达式实际上等效于：
```C++
cin >> num1
cin >> num2
cout << num1
cout << num2
```

***

## bit 和 Byte
### bit 
计算机中01序列的每一位就是一个bit，比如0010是4个bit 

### Byte
计算机可寻址的最小内存块为Byte，存储的基本单元被称为"字"（word），一个word一般由多个Byte构成，大多数机器的Byte由8个bit构成，而word则由4个或8个Byte构成

***

## 初始化
### 初始化和赋值的区别
初始化和赋值在C++中并不是一个概念，在一些其他语言中这二者可能是同一回事，在C++中二者的区别在大多数情况下也几乎可以忽略，但本质上在C++中二者有很大区别，因为初始化是在创建变量时为其赋予一个初始值，而赋值则把对象的当前值擦除再赋予一个新值。在初始化时常用 `=` 因此看起来像是在赋值一样，但实际上初始化不能等同于赋值

### 初始化的四种基本形式：
``` C++
int value = 0;
int value = {0}；
int value{0};
int value(0);
```
用花括号初始化是C++11引入的新特性，这种初始化形式被称为列表初始化，在初始化时，如果有丢失信息的可能（比如用一个double的字面值对int进行初始化），编译器会报错

### 默认初始化
如果**变量定义于任何函数体之外**，在未显式初始化时，变量被默认初始化为0,如果**存在于函数体之内**，则**不被初始化**,未初始化的内置类型变量的值是未定义的，如果试图访问或拷贝则会引发错误。类的初始化形式则由自己定义。

***

## 指针和引用
### 引用
通过将声明符写成&d的形式来定义引用类型，其中d是变量名：
```C++
int val = 123;
int &refval = val;
```
引用必须被初始化，一般在初始化变量时，初始值会被拷贝到新建的对象上去，但引用在定义时，则是将引用和初始值绑定在一起，对引用的所有操作都相当于直接操作初始值对象。<br>
引用只能绑定在对象上，而不能与字面值或者某个表达式的计算结果绑定在一起。

### 指针
指针和引用类似，都实现了对对象的间接访问。但和引用又有些许不同：
1. 指针本是是一个对象，允许对指针进行赋值和拷贝，而且指针在其生命周期内可以先后指向不同的对象。
2. 指针无需在初始化的时候赋值，和其他内置类型一样，在块定义域内没有初始化的指针将会拥有一个不确定的值。
定义指针类型的方法将声明符写成*d的形式，其中d是变量名：
```C++
int *ip1, *ip2;
double *dp2;
```

### 空指针
空指针不指向任何对象，生成空指针有三种方法：
```C++
int *p1 = nullptr;
int *p2 = 0;

//需要先#include <cstdlib>
int *p3 = NULL;
```
指针对象被用于条件语句时，如果指针的值为0（即为空指针）则返回false，否则返回true。

### void* 指针
void* 是一种特殊的指针，可用于存放任意对象的地址。void* 本质上还是指针，不同的点在于我们对该地址中存放的是什么类型的对象并不了解。不能直接操作void* 指针，因为我们并不知道其指向的对象是什么类型，但是可以将其和别的指针进行比较操作，也可以作为函数的输入和输出，还可以赋值给其他void* 指针。

### 多个指针变量的定义
将*写在靠近类型的位置容易引起误导，例如：
```C++
int* p1, p2;
```
看起来容易被误解为定义了两个int的指针p1，p2。但实际上是定义了一个int的指针p1和int类型的变量p2。因此为了避免误解建议将*写在靠近变量名的位置：
```C++
int *p1, p2;
```
### 指向指针的引用
引用本身不是对象，因此不能定义指向引用的指针。但指针是对象，所以可以定义指向指针的引用。
```C++
int val = 42;
int *p = nullptr;
int *&r = p;

r = &val;
*r = 0;
```
值得注意的是指向指针的引用的写法是*&，在判断一个复杂的复合类型声明时，可以从右向左阅读变量，以上文为例，与变量r最近的修饰符是&，因此是一个引用，其余部分都是用于确定r引用的类型是什么，上文中是int *，因此引用的类型是int类型的指针。

***

## const关键字
### const的作用
const限定符用于定义值不能被改变的变量，用关键字`const`对其进行限定：
```C++
const int bufSize = 512;
```
被const修饰的变量必须初始化，一旦初始化之后值就不再能改变，任何试图向const对象写值的操作均会报错。const对象只在文件内部有效，当多个文件包含同名的const对象时，他们被视为每个文件内不同的变量。但若想在多个文件内共享const对象，则需要在声明和定义时对const对象添加extern关键字。也就是说，如果是非const变量，可以直接被其他文件共享，在需要共享的文件中声明extern就可以了，而被共享的变量则不需要添加extern关键字，但是如果是const变量，则被共享的变量也需要添加extern关键字。

### const引用
const引用不仅仅是对const对象的引用这么简单，例如：
```C++
int val = 1;
const int &r1 = val;
```
以上是合法的行为，`const int&`表明对常量的引用，它对引用能够做的行为进行了限制，不能通过引用来改变被引用对象的值，但是被引用对象本身是非常量的，所以被引用对象本身依然可以修改，只是不能通过常量引用r1来修改。但是，反过来：
```C++
const int val = 1;
int &r = val;
```
以上行为则是非法的，不能用非常量引用来引用常量。

### const指针
指向const的指针和指向const的引用类似，同样对指针能够做的行为进行了限制，不能通过指针来修改其指向对象的值，但被指向的对象本身可以是非常量，本身依然可以修改。并且，指向常量的指针自身也并非常量，因此可以被修改，可以指向其他对象：
```C++
int val = 1;
const int c = 2;
const int *p = &val;
p = &c;
*p = 2; 
//非法操作，不能通过指向常量的指针修改其指向对象的值，
//但指针本身并非常量，可以指向其他变量
```
常量指针则表面指针本身是一个常量，在声明时将*放到const前面：
```C++
int *const cp1 = &val;
const int *const cp2 = &c;
```
常量指针不能被修改，其指向的对象在初始化后就不能再改变了，但是被指向的对象本身可以是常量也可以是非常量，如果是非常量则依然可以用解引用通过指针去修改指向对象的值

