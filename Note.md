## 对输入输出流的验证
### 输入流的结束标志
```
while(cin >> num1)
```
对于输入流，当输入流的类型非法（如输入char，被输入的变量为int），或者遇到文件结束符时，`cin >> num1`返回`false`, 每次回车将会把当前行的内容传给流，遇到空格结束，因此若输入 `1 2 3 y` 在回车时，因为有非法字符，将结束循环。而输入 `1 2 3 4` 则不会，输入回车后会开启新的一行，等待输入。文件结束符在Windows下为Ctrl+Z，在Linux下则为Ctrl+D，文件结束符在一行内有别的内容用空格隔开时不会生效，例如: `1 2 3 Ctrl+D` Ctrl+D将无效。但是单独一行输入`Ctrl+D`将直接结束流的输入(不需要回车)

### 输入输出流的级联
```C++
cin >> num1 >> num2
cout << num1 << num2
```
输入输出流级联时，表达式从左向右进行运算，每次将内容写入流（或从流写入变量）时后，其返回流本身，因此上述表达式实际上等效于：
```C++
cin >> num1
cin >> num2
cout << num1
cout << num2
```
当输入一行以空格隔开时，直到按下回车为止，程序处于一个等待输入的状态。按下回车后，会将这一行输入全部通过cin写入变量，但是遇到第一个空格之后，第一个cin >> var的语句就结束了，此时会返回cin，之后空格之后的内容还在cin里，所以再一次遇到cin >> var2的时候，又会将剩下的内容写入变量，直到遇到空格或结束为止，以此类推。`cin >> var1 >> var2`的本质也是上述过程，只不过写在一行了而已。

## bit 和 Byte
### bit 
计算机中01序列的每一位就是一个bit，比如0010是4个bit 

### Byte
计算机可寻址的最小内存块为Byte，存储的基本单元被称为"字"（word），一个word一般由多个Byte构成，大多数机器的Byte由8个bit构成，而word则由4个或8个Byte构成

## 初始化
### 初始化和赋值的区别
初始化和赋值在C++中并不是一个概念，在一些其他语言中这二者可能是同一回事，在C++中二者的区别在大多数情况下也几乎可以忽略，但本质上在C++中二者有很大区别，因为初始化是在创建变量时为其赋予一个初始值，而赋值则把对象的当前值擦除再赋予一个新值。在初始化时常用 `=` 因此看起来像是在赋值一样，但实际上初始化不能等同于赋值

### 初始化的四种基本形式：
``` C++
int value = 0;
int value = {0}；
int value{0};
int value(0);
```
用花括号初始化是C++11引入的新特性，这种初始化形式被称为列表初始化，在初始化时，如果有丢失信息的可能（比如用一个double的字面值对int进行初始化），编译器会报错

### 默认初始化
如果**变量定义于任何函数体之外**，在未显式初始化时，变量被默认初始化为0,如果**存在于函数体之内**，则**不被初始化**,未初始化的内置类型变量的值是未定义的，如果试图访问或拷贝则会引发错误。类的初始化形式则由自己定义。

## 指针和引用
### 引用
通过将声明符写成&d的形式来定义引用类型，其中d是变量名：
```C++
int val = 123;
int &refval = val;
```
引用必须被初始化，一般在初始化变量时，初始值会被拷贝到新建的对象上去，但引用在定义时，则是将引用和初始值绑定在一起，对引用的所有操作都相当于直接操作初始值对象。<br>
引用只能绑定在对象上，而不能与字面值或者某个表达式的计算结果绑定在一起。

### 指针
指针和引用类似，都实现了对对象的间接访问。但和引用又有些许不同：
1. 指针本是是一个对象，允许对指针进行赋值和拷贝，而且指针在其生命周期内可以先后指向不同的对象。
2. 指针无需在初始化的时候赋值，和其他内置类型一样，在块定义域内没有初始化的指针将会拥有一个不确定的值。
定义指针类型的方法将声明符写成*d的形式，其中d是变量名：
```C++
int *ip1, *ip2;
double *dp2;
```

### 空指针
空指针不指向任何对象，生成空指针有三种方法：
```C++
int *p1 = nullptr;
int *p2 = 0;

//需要先#include <cstdlib>
int *p3 = NULL;
```
指针对象被用于条件语句时，如果指针的值为0（即为空指针）则返回false，否则返回true。

### void* 指针
void* 是一种特殊的指针，可用于存放任意对象的地址。void* 本质上还是指针，不同的点在于我们对该地址中存放的是什么类型的对象并不了解。不能直接操作void* 指针，因为我们并不知道其指向的对象是什么类型，但是可以将其和别的指针进行比较操作，也可以作为函数的输入和输出，还可以赋值给其他void* 指针。

### 多个指针变量的定义
将*写在靠近类型的位置容易引起误导，例如：
```C++
int* p1, p2;
```
看起来容易被误解为定义了两个int的指针p1，p2。但实际上是定义了一个int的指针p1和int类型的变量p2。因此为了避免误解建议将*写在靠近变量名的位置：
```C++
int *p1, p2;
```
### 指向指针的引用
引用本身不是对象，因此不能定义指向引用的指针。但指针是对象，所以可以定义指向指针的引用。
```C++
int val = 42;
int *p = nullptr;
int *&r = p;

r = &val;
*r = 0;
```
值得注意的是指向指针的引用的写法是*&，在判断一个复杂的复合类型声明时，可以从右向左阅读变量，以上文为例，与变量r最近的修饰符是&，因此是一个引用，其余部分都是用于确定r引用的类型是什么，上文中是int *，因此引用的类型是int类型的指针。

## const关键字
### const的作用
const限定符用于定义值不能被改变的变量，用关键字`const`对其进行限定：
```C++
const int bufSize = 512;
```
被const修饰的变量必须初始化，一旦初始化之后值就不再能改变，任何试图向const对象写值的操作均会报错。const对象只在文件内部有效，当多个文件包含同名的const对象时，他们被视为每个文件内不同的变量。但若想在多个文件内共享const对象，则需要在声明和定义时对const对象添加extern关键字。也就是说，如果是非const变量，可以直接被其他文件共享，在需要共享的文件中声明extern就可以了，而被共享的变量则不需要添加extern关键字，但是如果是const变量，则被共享的变量也需要添加extern关键字。

### const引用
const引用不仅仅是对const对象的引用这么简单，例如：
```C++
int val = 1;
const int &r1 = val;
```
以上是合法的行为，`const int&`表明对常量的引用，它对引用能够做的行为进行了限制，不能通过引用来改变被引用对象的值，但是被引用对象本身是非常量的，所以被引用对象本身依然可以修改，只是不能通过常量引用r1来修改。但是，反过来：
```C++
const int val = 1;
int &r = val;
```
以上行为则是非法的，不能用非常量引用来引用常量。

### const指针
指向const的指针和指向const的引用类似，同样对指针能够做的行为进行了限制，不能通过指针来修改其指向对象的值，但被指向的对象本身可以是非常量，本身依然可以修改。并且，指向常量的指针自身也并非常量，因此可以被修改，可以指向其他对象：
```C++
int val = 1;
const int c = 2;
const int *p = &val;
p = &c;
*p = 2; 
//非法操作，不能通过指向常量的指针修改其指向对象的值，
//但指针本身并非常量，可以指向其他变量
```
常量指针则表面指针本身是一个常量，在声明时将*放到const前面：
```C++
int *const cp1 = &val;
const int *const cp2 = &c;
```
常量指针不能被修改，其指向的对象在初始化后就不能再改变了，但是被指向的对象本身可以是常量也可以是非常量，如果是非常量则依然可以用解引用通过指针去修改指向对象的值

## constexpr常量表达式
常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。C++11的新标准允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式
```C++
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz = size();//仅当size是constexpr函数时才正确
```
constexpr的作用更像是提醒编译器帮我们来检查一个变量是否为常量表达式，一般来说如果我们认为变量是一个常量表达式，那就把它声明为constexpr类型，这样如果实际上在我们的程序中他不是一个常量表达式，编译器则会报错来提示我们。

### constexpr指针
constexpr指针中，constexpr限定符仅对指针有效，而与指针指向的对象无关，也就是说constexpr只能是顶层const：
```C++
const int *p = nullptr;
constexpr int *q = nullptr;
```
p是底层const，而q检查的是顶层const。<br>
由于常数表达式的定义是在编译过程就能知道计算结果，所以constexpr指针和引用的初始值会被严格限制，一般来说，只能用在函数体之外的变量的地址来初始化他们，因为函数体内的变量的地址不是固定不变的，无法在编译过程就得到其固定的值。

## typedef 关键字
typedef是类型别名，为类型起一个同义词，typedef对类型定义别名的语法为：
```C++
typedef double wages;
typedef wages base, *p;
```
C++11还规定了一种新方法：别名声明，来定义类型的别名：
```C++
using SI = Sales_item;
```
将等式左边的名字规定成等式右边的别名。

### const+类型别名
以下面这段代码为例：
```C++
typedef char *pstring;
const pstring ctr = 0;
``` 
const修饰的是整个pstring，也就是说pstring是常量，所以ctr是一个指向char类型的常量指针（顶层const）
容易误导的是，如果将pstring代入到代码中，`const char *pstring`看起来像是底层const，因此不能习惯于将别名代入回代码来研究其含义。

## auto 关键字
auto关键字可以让编译器替我们去分析表达式所属的类型，auto变量的定义必须有初始值。使用auto在一条语句中声明多个变量的时候，所有变量的初始基本数据类型必须一样。

### auto和引用
用auto做类型时，如果用引用来初始化，则编译器会根据引用的对象来推断auto的类型：
```C++
int i = 0, &r = i;
auto a = r;
```
上述代码中a的属性为int，而不是int&。因为引用不是对象，而只是别名，因此此处相当于用i的值来推断a的类型，因此是int。

### const和auto
auto关键字会忽略初始值的顶层const属性，但是会保留其底层const，比如当初始值是一个指向常量的指针时：
```C++
const int ci = i, &cr = ci;
auto b = ci; //b是int类型，忽略了顶层const
auto d = &i; //i是int，用i的地址来推d的类型，所以是int*
auto e = &ci; //ci是const int, 用ci的地址来推e，保留底层const属性，因此是const int*
```
如果希望推断出的auto类型是顶层const，则需要手动添加const关键字：
```C++
const auto f = ci;//f的类型是const int
```
对于忽略顶层const这个点，在用auto声明指针和引用时值得注意，用于初始化的对象的顶层const属性仍然被保留：
```C++
const int ci = 1;
auto a = ci; //auto为int，忽略了顶层const属性
auto &r = ci, *p = &ci; 
//此时给auto&和auto*推断属性，所以ci的const的顶层const属性得以保留
```

## decltype关键字
decltype同样可以通过表达式来推断类型，但不会用该表达式的值来初始化变量。decltype和auto在使用上有些许不同，decltype使用的表达式是否是一个变量会产生不同的结果：
1. 当表达式是变量时<br>
decltype将返回该变量的类型，顶层const也会保留，引用也会直接返回引用类型本身（而不是返回被引用的类型）
    ```C++
    const int ci = 0, &cj = ci;
    decltype(ci) x = 0;//x的类型是const int，保留了顶层属性
    decltype(cj) y = x;//y的类型是const int&，返回的是引用类型本身而不是被引用的对象 
    ```
    引用大部分时候都是作为别名存在，即实际上相当于操作被引用的对象，只有在decltype里是例外，其返回的是引用自身。
2. 当表达式不是变量时<br>
decltype会返回该表达式的结果类型。值得注意的是*p这种解引用操作是一个表达式，其返回值是对对象的引用。
    ```C++
    int i = 42, *p = &i, &r = i;
    decltype(r + 1) b;//r本身是变量，但是r+1是表达式，因此返回r+1的结果类型int
    decltype(*p) c;//错误，因为*p是表达式而不是变量，所以返回*p的结果类型int*
    ```
    另外特别值得注意的点是，如果变量名被加了括号，编译器就会把他当做是一个表达式而非变量来处理，该类表达式的结果引用类型：
    ```C++
    decltype((i)) d;//(i)被看成是表达式，返回值类型是int&
    decltype(i) e;//i是变量，所以返回int类型
    ```
    牢记decltype((variable))的结果永远是引用，但decltype(variable)只有在variable自身是引用的时候结果才是引用类型。

## C++版本的头文件
C++标准库兼容了C语言的标准库，C语言的标准库一般都是name.h的形式，C++则将这些文件命名为cname，去掉.h后缀后在名字前添加字母c，表明这是一个属于C标准库的头文件。因此cname和name.h两个文件是等价，从功能上讲用哪个都可以，但是一般建议在C++中使用C++版本的头文件。并且在cname的头文件中定义的名字从属于namespace std，而定义在name.h中的则不然。这样的好处是标准库中的名字总能在std中被找到，如果使用.h的话开发者就不得不时刻牢记哪些是从C语言继承来的，哪些又是C++所独有的。

## 标准库string
标准库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件，作为标准库的一部分，string定义在命名空间std中，因此在使用前必须先包含：
```C++
#include <string>
using std::string;
```
### 初始化方式
可以用一个字面值或者string对象来对string进行初始化，也可以使用一个数字和一个字符来进行初始化，得到到结果是多个该字符构成的字符串：
```C++
string s1;
string s2 = s1;
string s2(s1);
string s3 = "abcd";
string s3("abcd");
string s4(10, 'c'); //s4的值为ccccccccccc
```

### 对string的操作
```C++
cin >> s;
cout << s;
```
输入输出流和其他基本类型一样，可以从输入流写入或者输出到输出流。
```C++
getline(cin, s);
```
getline函数可以一次读取一行的数据写入字符串，包括空格，这样就可以将空格写入到string当中去，但最后的回车符没有写进string，因此输出时如果要换行还是需要手动加上换行符。getline的返回值就是参数中的cin，因此可以将getline函数直接作为while的判断条件，就像while(cin >> s)一样。
```C++
s.empty();
s.size();
```
empty和size函数用来判断字符串是否为空以及返回字符串的长度。

### string::size_type类型
s.size()的返回值并不是unsigned或者int，而是string::size_type，这个类型是一个无符号的数，按理说用于存放s.size()函数的返回值的变量都应该是string::size_type类型。在C++11引入auto和decltype之后，可以更加方便的使用这种类型，如：
```C++
auto len = s.size();
decltype(s.size()) len;
```
由于size_type是无符号数，因此如果在表达式中混用了带符号数与无符号数则可能发生错误，因此如果要用size_type进行计算的话要特别注意参与运算的变量类型。

### string的比较
在两个string对象进行比较时：
1. 如果两个string对象在某些位置上的字符不相同，则第一对不相同的字符的比较结果将作为两个string对象的比较结果，两个字符的比较依据大小写敏感的字典顺序。
2. 如果两个string对象长度不同，但是一个string是另一个的子串，则短的那个小于长的string，如果长度也相同则认为两个string相等。

### 给string的赋值
允许把一个string赋值给另一个string，也允许把一个字面值赋值给string。但需要注意的是，出于一些历史原因以及为了和C兼容，**C++中的字符串字面值和string并不是同一种类型**，因此无论是用字符串字面值给string赋值还是通过加法运算来拼接字符串，本质上在其中都隐含了从字符串字面值到string的类型转换。在进行字符串拼接时，必须保证加号两侧至少要有一个string对线，这样才能将字面值转化为string类型后进行加法运算。如果加号两侧都是字符串字面值则会发生错误，因为字符串字面值这种类型不能进行加法运算。举例说明：
```C++
string s4 = s1 + ", ";//正确，","被转化成了string后进行加法操作
string s5 = "hello" + ", ";//错误，字符串字面值不能进行加法操作
string s6 = s1 + ", " + "world";//正确，s1和","运算后返回string继续和"world"运算
string s7 = "hello" + ", " + s2;//错误，"hello" + ", "已经出现错误
```

