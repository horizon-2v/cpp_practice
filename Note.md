## 对输入输出流的验证
### 输入流的结束标志
```
while(cin >> num1)
```
对于输入流，当输入流的类型非法（如输入char，被输入的变量为int），或者遇到文件结束符时，`cin >> num1`返回`false`, 每次回车将会把当前行的内容传给流，遇到空格结束，因此若输入 `1 2 3 y` 在回车时，因为有非法字符，将结束循环。而输入 `1 2 3 4` 则不会，输入回车后会开启新的一行，等待输入。文件结束符在Windows下为Ctrl+Z，在Linux下则为Ctrl+D，文件结束符在一行内有别的内容用空格隔开时不会生效，例如: `1 2 3 Ctrl+D` Ctrl+D将无效。但是单独一行输入`Ctrl+D`将直接结束流的输入(不需要回车)

### 输入输出流的级联
```C++
cin >> num1 >> num2
cout << num1 << num2
```
输入输出流级联时，表达式从左向右进行运算，每次将内容写入流（或从流写入变量）时后，其返回流本身，因此上述表达式实际上等效于：
```C++
cin >> num1
cin >> num2
cout << num1
cout << num2
```
当输入一行以空格隔开时，直到按下回车为止，程序处于一个等待输入的状态。按下回车后，会将这一行输入全部通过cin写入变量，但是遇到第一个空格之后，第一个cin >> var的语句就结束了，此时会返回cin，之后空格之后的内容还在cin里，所以再一次遇到cin >> var2的时候，又会将剩下的内容写入变量，直到遇到空格或结束为止，以此类推。`cin >> var1 >> var2`的本质也是上述过程，只不过写在一行了而已。

## bit 和 Byte
### bit 
计算机中01序列的每一位就是一个bit，比如0010是4个bit 

### Byte
计算机可寻址的最小内存块为Byte，存储的基本单元被称为"字"（word），一个word一般由多个Byte构成，大多数机器的Byte由8个bit构成，而word则由4个或8个Byte构成

## 初始化
### 初始化和赋值的区别
初始化和赋值在C++中并不是一个概念，在一些其他语言中这二者可能是同一回事，在C++中二者的区别在大多数情况下也几乎可以忽略，但本质上在C++中二者有很大区别，因为初始化是在创建变量时为其赋予一个初始值，而赋值则把对象的当前值擦除再赋予一个新值。在初始化时常用 `=` 因此看起来像是在赋值一样，但实际上初始化不能等同于赋值

### 初始化的四种基本形式：
``` C++
int value = 0;
int value = {0}；
int value{0};
int value(0);
```
用花括号初始化是C++11引入的新特性，这种初始化形式被称为列表初始化，在初始化时，如果有丢失信息的可能（比如用一个double的字面值对int进行初始化），编译器会报错

### 默认初始化
如果**变量定义于任何函数体之外**，在未显式初始化时，变量被默认初始化为0,如果**存在于函数体之内**，则**不被初始化**,未初始化的内置类型变量的值是未定义的，如果试图访问或拷贝则会引发错误。类的初始化形式则由自己定义。

## 指针和引用
### 引用
通过将声明符写成&d的形式来定义引用类型，其中d是变量名：
```C++
int val = 123;
int &refval = val;
```
引用必须被初始化，一般在初始化变量时，初始值会被拷贝到新建的对象上去，但引用在定义时，则是将引用和初始值绑定在一起，对引用的所有操作都相当于直接操作初始值对象。<br>
引用只能绑定在对象上，而不能与字面值或者某个表达式的计算结果绑定在一起。

### 指针
指针和引用类似，都实现了对对象的间接访问。但和引用又有些许不同：
1. 指针本是是一个对象，允许对指针进行赋值和拷贝，而且指针在其生命周期内可以先后指向不同的对象。
2. 指针无需在初始化的时候赋值，和其他内置类型一样，在块定义域内没有初始化的指针将会拥有一个不确定的值。
定义指针类型的方法将声明符写成*d的形式，其中d是变量名：
```C++
int *ip1, *ip2;
double *dp2;
```

### 空指针
空指针不指向任何对象，生成空指针有三种方法：
```C++
int *p1 = nullptr;
int *p2 = 0;

//需要先#include <cstdlib>
int *p3 = NULL;
```
指针对象被用于条件语句时，如果指针的值为0（即为空指针）则返回false，否则返回true。

### void* 指针
void* 是一种特殊的指针，可用于存放任意对象的地址。void* 本质上还是指针，不同的点在于我们对该地址中存放的是什么类型的对象并不了解。不能直接操作void* 指针，因为我们并不知道其指向的对象是什么类型，但是可以将其和别的指针进行比较操作，也可以作为函数的输入和输出，还可以赋值给其他void* 指针。

### 多个指针变量的定义
将*写在靠近类型的位置容易引起误导，例如：
```C++
int* p1, p2;
```
看起来容易被误解为定义了两个int的指针p1，p2。但实际上是定义了一个int的指针p1和int类型的变量p2。因此为了避免误解建议将*写在靠近变量名的位置：
```C++
int *p1, p2;
```
### 指向指针的引用
引用本身不是对象，因此不能定义指向引用的指针。但指针是对象，所以可以定义指向指针的引用。
```C++
int val = 42;
int *p = nullptr;
int *&r = p;

r = &val;
*r = 0;
```
值得注意的是指向指针的引用的写法是*&，在判断一个复杂的复合类型声明时，可以从右向左阅读变量，以上文为例，与变量r最近的修饰符是&，因此是一个引用，其余部分都是用于确定r引用的类型是什么，上文中是int *，因此引用的类型是int类型的指针。

## const关键字
### const的作用
const限定符用于定义值不能被改变的变量，用关键字`const`对其进行限定：
```C++
const int bufSize = 512;
```
被const修饰的变量必须初始化，一旦初始化之后值就不再能改变，任何试图向const对象写值的操作均会报错。const对象只在文件内部有效，当多个文件包含同名的const对象时，他们被视为每个文件内不同的变量。但若想在多个文件内共享const对象，则需要在声明和定义时对const对象添加extern关键字。也就是说，如果是非const变量，可以直接被其他文件共享，在需要共享的文件中声明extern就可以了，而被共享的变量则不需要添加extern关键字，但是如果是const变量，则被共享的变量也需要添加extern关键字。

### const引用
const引用不仅仅是对const对象的引用这么简单，例如：
```C++
int val = 1;
const int &r1 = val;
```
以上是合法的行为，`const int&`表明对常量的引用，它对引用能够做的行为进行了限制，不能通过引用来改变被引用对象的值，但是被引用对象本身是非常量的，所以被引用对象本身依然可以修改，只是不能通过常量引用r1来修改。但是，反过来：
```C++
const int val = 1;
int &r = val;
```
以上行为则是非法的，不能用非常量引用来引用常量。

### const指针
指向const的指针和指向const的引用类似，同样对指针能够做的行为进行了限制，不能通过指针来修改其指向对象的值，但被指向的对象本身可以是非常量，本身依然可以修改。并且，指向常量的指针自身也并非常量，因此可以被修改，可以指向其他对象：
```C++
int val = 1;
const int c = 2;
const int *p = &val;
p = &c;
*p = 2; 
//非法操作，不能通过指向常量的指针修改其指向对象的值，
//但指针本身并非常量，可以指向其他变量
```
常量指针则表面指针本身是一个常量，在声明时将*放到const前面：
```C++
int *const cp1 = &val;
const int *const cp2 = &c;
```
常量指针不能被修改，其指向的对象在初始化后就不能再改变了，但是被指向的对象本身可以是常量也可以是非常量，如果是非常量则依然可以用解引用通过指针去修改指向对象的值

## constexpr常量表达式
常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。C++11的新标准允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式
```C++
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz = size();//仅当size是constexpr函数时才正确
```
constexpr的作用更像是提醒编译器帮我们来检查一个变量是否为常量表达式，一般来说如果我们认为变量是一个常量表达式，那就把它声明为constexpr类型，这样如果实际上在我们的程序中他不是一个常量表达式，编译器则会报错来提示我们。

### constexpr指针
constexpr指针中，constexpr限定符仅对指针有效，而与指针指向的对象无关，也就是说constexpr只能是顶层const：
```C++
const int *p = nullptr;
constexpr int *q = nullptr;
```
p是底层const，而q检查的是顶层const。<br>
由于常数表达式的定义是在编译过程就能知道计算结果，所以constexpr指针和引用的初始值会被严格限制，一般来说，只能用在函数体之外的变量的地址来初始化他们，因为函数体内的变量的地址不是固定不变的，无法在编译过程就得到其固定的值。

## typedef 关键字
typedef是类型别名，为类型起一个同义词，typedef对类型定义别名的语法为：
```C++
typedef double wages;
typedef wages base, *p;
```
C++11还规定了一种新方法：别名声明，来定义类型的别名：
```C++
using SI = Sales_item;
```
将等式左边的名字规定成等式右边的别名。

### const+类型别名
以下面这段代码为例：
```C++
typedef char *pstring;
const pstring ctr = 0;
``` 
const修饰的是整个pstring，也就是说pstring是常量，所以ctr是一个指向char类型的常量指针（顶层const）
容易误导的是，如果将pstring代入到代码中，`const char *pstring`看起来像是底层const，因此不能习惯于将别名代入回代码来研究其含义。

## auto 关键字
auto关键字可以让编译器替我们去分析表达式所属的类型，auto变量的定义必须有初始值。使用auto在一条语句中声明多个变量的时候，所有变量的初始基本数据类型必须一样。

### auto和引用
用auto做类型时，如果用引用来初始化，则编译器会根据引用的对象来推断auto的类型：
```C++
int i = 0, &r = i;
auto a = r;
```
上述代码中a的属性为int，而不是int&。因为引用不是对象，而只是别名，因此此处相当于用i的值来推断a的类型，因此是int。

### const和auto
auto关键字会忽略初始值的顶层const属性，但是会保留其底层const，比如当初始值是一个指向常量的指针时：
```C++
const int ci = i, &cr = ci;
auto b = ci; //b是int类型，忽略了顶层const
auto d = &i; //i是int，用i的地址来推d的类型，所以是int*
auto e = &ci; //ci是const int, 用ci的地址来推e，保留底层const属性，因此是const int*
```
如果希望推断出的auto类型是顶层const，则需要手动添加const关键字：
```C++
const auto f = ci;//f的类型是const int
```
对于忽略顶层const这个点，在用auto声明指针和引用时值得注意，用于初始化的对象的顶层const属性仍然被保留：
```C++
const int ci = 1;
auto a = ci; //auto为int，忽略了顶层const属性
auto &r = ci, *p = &ci; 
//此时给auto&和auto*推断属性，所以ci的const的顶层const属性得以保留
```

## decltype关键字
decltype同样可以通过表达式来推断类型，但不会用该表达式的值来初始化变量。decltype和auto在使用上有些许不同，decltype使用的表达式是否是一个变量会产生不同的结果：
1. 当表达式是变量时<br>
decltype将返回该变量的类型，顶层const也会保留，引用也会直接返回引用类型本身（而不是返回被引用的类型）
    ```C++
    const int ci = 0, &cj = ci;
    decltype(ci) x = 0;//x的类型是const int，保留了顶层属性
    decltype(cj) y = x;//y的类型是const int&，返回的是引用类型本身而不是被引用的对象 
    ```
    引用大部分时候都是作为别名存在，即实际上相当于操作被引用的对象，只有在decltype里是例外，其返回的是引用自身。
2. 当表达式不是变量时<br>
decltype会返回该表达式的结果类型。值得注意的是*p这种解引用操作是一个表达式，其返回值是对对象的引用。
    ```C++
    int i = 42, *p = &i, &r = i;
    decltype(r + 1) b;//r本身是变量，但是r+1是表达式，因此返回r+1的结果类型int
    decltype(*p) c;//错误，因为*p是表达式而不是变量，所以返回*p的结果类型int*
    ```
    另外特别值得注意的点是，如果变量名被加了括号，编译器就会把他当做是一个表达式而非变量来处理，该类表达式的结果引用类型：
    ```C++
    decltype((i)) d;//(i)被看成是表达式，返回值类型是int&
    decltype(i) e;//i是变量，所以返回int类型
    ```
    牢记decltype((variable))的结果永远是引用，但decltype(variable)只有在variable自身是引用的时候结果才是引用类型。

## C++版本的头文件
C++标准库兼容了C语言的标准库，C语言的标准库一般都是name.h的形式，C++则将这些文件命名为cname，去掉.h后缀后在名字前添加字母c，表明这是一个属于C标准库的头文件。因此cname和name.h两个文件是等价，从功能上讲用哪个都可以，但是一般建议在C++中使用C++版本的头文件。并且在cname的头文件中定义的名字从属于namespace std，而定义在name.h中的则不然。这样的好处是标准库中的名字总能在std中被找到，如果使用.h的话开发者就不得不时刻牢记哪些是从C语言继承来的，哪些又是C++所独有的。

## 标准库string
标准库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件，作为标准库的一部分，string定义在命名空间std中，因此在使用前必须先包含：
```C++
#include <string>
using std::string;
```
### 初始化方式
可以用一个字面值或者string对象来对string进行初始化，也可以使用一个数字和一个字符来进行初始化，得到到结果是多个该字符构成的字符串：
```C++
string s1;
string s2 = s1;
string s2(s1);
string s3 = "abcd";
string s3("abcd");
string s4(10, 'c'); //s4的值为ccccccccccc
```

### 对string的操作
```C++
cin >> s;
cout << s;
```
输入输出流和其他基本类型一样，可以从输入流写入或者输出到输出流。
```C++
getline(cin, s);
```
getline函数可以一次读取一行的数据写入字符串，包括空格，这样就可以将空格写入到string当中去，但最后的回车符没有写进string，因此输出时如果要换行还是需要手动加上换行符。getline的返回值就是参数中的cin，因此可以将getline函数直接作为while的判断条件，就像while(cin >> s)一样。
```C++
s.empty();
s.size();
```
empty和size函数用来判断字符串是否为空以及返回字符串的长度。

### string::size_type类型
s.size()的返回值并不是unsigned或者int，而是string::size_type，这个类型是一个无符号的数，按理说用于存放s.size()函数的返回值的变量都应该是string::size_type类型。在C++11引入auto和decltype之后，可以更加方便的使用这种类型，如：
```C++
auto len = s.size();
decltype(s.size()) len;
```
由于size_type是无符号数，因此如果在表达式中混用了带符号数与无符号数则可能发生错误，因此如果要用size_type进行计算的话要特别注意参与运算的变量类型。

### string的比较
在两个string对象进行比较时：
1. 如果两个string对象在某些位置上的字符不相同，则第一对不相同的字符的比较结果将作为两个string对象的比较结果，两个字符的比较依据大小写敏感的字典顺序。
2. 如果两个string对象长度不同，但是一个string是另一个的子串，则短的那个小于长的string，如果长度也相同则认为两个string相等。

### 给string的赋值
允许把一个string赋值给另一个string，也允许把一个字面值赋值给string。但需要注意的是，出于一些历史原因以及为了和C兼容，**C++中的字符串字面值和string并不是同一种类型**，因此无论是用字符串字面值给string赋值还是通过加法运算来拼接字符串，本质上在其中都隐含了从字符串字面值到string的类型转换。在进行字符串拼接时，必须保证加号两侧至少要有一个string对线，这样才能将字面值转化为string类型后进行加法运算。如果加号两侧都是字符串字面值则会发生错误，因为字符串字面值这种类型不能进行加法运算。举例说明：
```C++
string s4 = s1 + ", ";//正确，","被转化成了string后进行加法操作
string s5 = "hello" + ", ";//错误，字符串字面值不能进行加法操作
string s6 = s1 + ", " + "world";//正确，s1和","运算后返回string继续和"world"运算
string s7 = "hello" + ", " + s2;//错误，"hello" + ", "已经出现错误
```

### 遍历string中的字符
可以使用范围for（for each）语句来便利string中的每一个字符：
```C++
string str("some string");
for(auto c : str)
    cout << c << endl;
```
如果想要通过遍历的方式改变string中的字符，可以在范围for中加入引用类型：
```C++
string str("some string");
for(auto &c : str)
    c = toupper(c);
cout << str << endl;
```

### 访问string中的某一个字符
可以使用下表运算符[]来访问某一个字符，下表运算符接受的输入参数的类型是string::size_type。下标的取值范围必须大于0而小于str.size()，否则可能会出现不可预料的后果。下标运算符返回的是下标对应的字符的引用。

## 标准库vector
标准库vector表示对象的集合，存放相同类型的对象，每一个对象都有一个与之对应的索引，因为集合存放着其他对象，因此也被称之为容器。使用vector之前，必须包含相应的头文件，并且要使用using语句：
```C++
#include <vector>
using std::vector;
```
vector本身是一个类模板，类模板本身并不是类，编译器会根据模板创建类或者函数，给类模板提供信息的方式是在模板后面跟一个<>，在<>内放上信息。vector需要提供的额外信息是存放对象的类型：
```C++
vector<int> ivec;
vector<Sales_Item> Sales_vec;
vector<vector<string>> file;
```
注意，引用因为不是对象，因此不能放在vector内。

### vector的定义和初始化
可以用一个已有的vector对象来对一个新的vector进行初始化，也可以用一个数字和存放类型的变量进行初始化，结果是复数个该变量值的vector，也可以只用一个数字来初始化，结果是复合个默认初始化的变量，也可以用花括号直接初始化，用花括号内的结果作为vector的初始化值。
```C++
vector<T> v1;
vector<T> v2 = v1;//通过已有vector进行初始化
vector<T> v2 = v1；
vector<T> v3(n, val);//结果是n个val的vector
vector<T> v4(n);//结果是n个默认初始化的vector
vector<T> v5{a, b, c};//结果是存放了a, b, c的vector
vector<T> v6 = {a, b, c};
```
注意，列表初始化还有两种特殊情况，但不建议使用：
```C++
vector<string> v7{10};
vector<string> v8{10, "hi"};
```
以上两种情况，编译器不会报错。在这种情况下，因为是用花括号包着的列表，编译器首先尝试进行列表初始化，但由于int类型的10不能初始化成string对象，因此编译器会尝试普通的初始化，因此这两行代码会等效于圆括号包着的10和10，“hi”，所以初始化的结果是v7是10个默认初始化的值，v8是10个“hi”。

### 向vector中添加元素
使用vector的push_back方法可以在vector的末尾添加元素：
```C++
vector<int> v2;
for(i = 0; i < 100; i++){
    v2.push_back(i);
}
```

### vector的其他操作
vector的操作与string的基本相同：
```C++
v.empty();
v.size();
v.push_back(t);
v[n];
v1 = v2;
v1 = {a, b, c};
v1 == v2;
v1 != v2;
<, <=, >, >=
```
v.size的返回值类型同样是vector<T>::size_type，注意不能省去尖括号和里面的内容。比较运算符和string一样，比较第一个不相同的元素，如果完全相同就比较长度。vector的下标运算符也和string一样，返回的该位置元素的引用，但值得注意的是，不能通过下标运算符来访问不存在的位置的元素，因此也不能通过下标运算符来添加元素，必须使用push_back方法。

## 迭代器
迭代器和指针类似，也可以间接的访问对象，使用迭代器可以访问容器或string中的某个元素，也能从一个元素移动到另一个元素，一个有效的迭代器指向某一个元素，或者指向容器中尾元素的下一位置。值得注意的是，string本质上不是容器，但是它的很多操作和容器类似，其中就包括迭代器。

### 获得迭代器对象
迭代器对象并不是通过取地址运算符赋值的，凡是拥有迭代器的容器都有返回迭代器成员的方法begin()和end()：
```C++
auto b = v.begin(), e = v.end;()
```
begin方法返回的是指向容器中第一个对象的迭代器，end方法则是返回指向容器中尾元素的下一位置的迭代器。如果容器为空，那么begin和end返回的是同一个迭代器，都是尾后迭代器。迭代器使用的时候和指针几乎相同：
```C++
*item;
item -> mem;
++item;
--item;
item1 == item2;
item2 != item2; 
```
可以通过解引用操作访问迭代器指向的元素，也可以用->操作访问指向对象的成员。迭代器的++和--操作会使迭代器指向下一个或者上一个元素，在迭代器指向同一个对象的时候判定为两个迭代器相等。

### 迭代器的类型
迭代器的类型是iterator，如果是只读的迭代器，则是const_iterator：
```C++
vector<int>::iterator it;
string:iterator it2;
vector<int>::const_iterator it3;
string::const_iterator it4;
```
const_iterator是一个类似底层const的指针的类型，即不能通过迭代器来改变指向对象的值，但迭代器本身可以自由移动。如果容器或者string对象是常量，则只能使用常量迭代器，如果容器或者string不是常量，则既可以使用普通迭代器也可以使用常量迭代器。实际使用时也可以用auto来获取迭代器的类型<br>
如果一个容器或string本身是常量，那么begin和end返回的迭代器类型是const_iterator，该容器本身也只能使用const_iterator，但是如果是非常量的容器和string，begin和end返回的是iterator，如果我们想使用一个常量迭代器，可以使用`cbegin()`和`cend()`。

### 迭代器失效
任何使得容器的容量发生变化的操作均会使迭代器失效，最典型的例子是`push_back()`操作，因此但凡使用了迭代器的循环体，都不要像容器中添加元素。

### 迭代器的运算
迭代器可以进行算术运算：
```C++
iter + n
iter - n
iter += n;
iter -= n;
iter1 - iter2;
>, <, >=, <=
```
迭代器的加减分别指的是迭代器向前和向后的操作，这一点和item++和item--相对应，iter + n表示迭代器向前移动n个位置，同样iter - n表示向后移动n个位置。两个迭代器相减则定义为，运算符右侧的迭代器需要向前移动多少位置才能到达运算符左侧的迭代器的位置，差值结果的类型为`difference_type`该类型是一个带符号的整数，一般使用时可以直接用auto获取他的类型。