### 对输入输出流的验证
1. 输入流的结束标志
    ```
    while(cin >> num1)
    ```
    对于输入流，当输入流的类型非法（如输入char，被输入的变量为int），或者遇到文件结束符时，`cin >> num1`返回`false`, 每次回车将会把当前行的内容传给流，遇到空格结束，因此若输入 `1 2 3 y` 在回车时，因为有非法字符，将结束循环。而输入 `1 2 3 4` 则不会，输入回车后会开启新的一行，等待输入。文件结束符在Windows下为Ctrl+Z，在Linux下则为Ctrl+D，文件结束符在一行内有别的内容用空格隔开时不会生效，例如: `1 2 3 Ctrl+D` Ctrl+D将无效。但是单独一行输入`Ctrl+D`将直接结束流的输入（不需要回车）
2. 输入输出流的级联
    ```
    cin >> num1 >> num2
    cout << num1 << num2
    ```
    输入输出流级联时，表达式从左向右进行运算，每次将内容写入流（或从流写入变量）时后，其返回流本身，因此上述表达式实际上等效于：
    ```
    cin >> num1
    cin >> num2
    cout << num1
    cout << num2
    ```
## bit 和 Byte
### bit 
计算机中01序列的每一位就是一个bit，比如0010是4个bit 
### Byte
计算机可寻址的最小内存块为Byte，存储的基本单元被称为"字"（word），一个word一般由多个Byte构成，大多数机器的Byte由8个bit构成，而word则由4个或8个Byte构成

## 初始化
### 初始化和赋值的区别
初始化和赋值在C++中并不是一个概念，在一些其他语言中这二者可能是同一回事，在C++中二者的区别在大多数情况下也几乎可以忽略，但本质上在C++中二者有很大区别，因为初始化是在创建变量时为其赋予一个初始值，而赋值则把对象的当前值擦除再赋予一个新值。在初始化时常用 `=` 因此看起来像是在赋值一样，但实际上初始化不能等同于赋值
### 初始化的四种基本形式：
``` C++
   int value = 0;
   int value = {0}；
   int value{0};
   int value(0);
```
用花括号初始化是C++11引入的新特性，这种初始化形式被称为列表初始化，在初始化时，如果有丢失信息的可能（比如用一个double的字面值对int进行初始化），编译器会报错
### 默认初始化
如果**变量定义于任何函数体之外**，在未显式初始化时，变量被默认初始化为0,如果**存在于函数体之内**，则**不被初始化**,未初始化的内置类型变量的值是未定义的，如果试图访问或拷贝则会引发错误。类的初始化形式则由自己定义。
## 指针和引用
### 引用
通过将声明符写成&d的形式来定义引用类型，其中d是变量名：
```C++
int val = 123;
int &refval = val;
```
引用必须被初始化，一般在初始化变量时，初始值会被拷贝到新建的对象上去，但引用在定义时，则是将引用和初始值绑定在一起，对引用的所有操作都相当于直接操作初始值对象。<br>
引用只能绑定在对象上，而不能与字面值或者某个表达式的计算结果绑定在一起。
### 指针
指针和引用类似，都实现了对对象的间接访问。但和引用又有些许不同：
1. 指针本是是一个对象，允许对指针进行赋值和拷贝，而且指针在其生命周期内可以先后指向不同的对象。
2. 指针无需在初始化的时候赋值，和其他内置类型一样，在块定义域内没有初始化的指针将会拥有一个不确定的值。
定义指针类型的方法将声明符写成*d的形式，其中d是变量名：
```C++
int *ip1, *ip2;
double *dp2;
```
#### 空指针
空指针不指向任何对象，生成空指针有三种方法：
```C++
int *p1 = nullptr;
int *p2 = 0;

//需要先#include <cstdlib>
int *p3 = NULL;
```
指针对象被用于条件语句时，如果指针的值为0（即为空指针）则返回false，否则返回true。

#### void* 指针
void* 是一种特殊的指针，可用于存放任意对象的地址。void* 本质上还是指针，不同的点在于我们对该地址中存放的是什么类型的对象并不了解。不能直接操作void* 指针，因为我们并不知道其指向的对象是什么类型，但是可以将其和别的指针进行比较操作，也可以作为函数的输入和输出，还可以赋值给其他void* 指针。

#### 多个指针变量的定义
将*写在靠近类型的位置容易引起误导，例如：
```C++
int* p1, p2;
```
看起来容易被误解为定义了两个int的指针p1，p2。但实际上是定义了一个int的指针p1和int类型的变量p2。因此为了避免误解建议将*写在靠近变量名的位置：
```C++
int *p1, p2;
```
#### 指向指针的引用
引用本身不是对象，因此不能定义指向引用的指针。但指针是对象，所以可以定义指向指针的引用。
```C++
int val = 42;
int *p = nullptr;
int *&r = p;

r = &val;
*r = 0;
```
值得注意的是指向指针的引用的写法是*&，在判断一个复杂的复合类型声明时，可以从右向左阅读变量，以上文为例，与变量r最近的修饰符是&，因此是一个引用，其余部分都是用于确定r引用的类型是什么，上文中是int *，因此引用的类型是int类型的指针。